/*
 *	osgART/Marker
 *	osgART: AR ToolKit for OpenSceneGraph
 *
 *	Copyright (c) 2005-2007 ARToolworks, Inc. All rights reserved.
 *	
 *	Rev		Date		Who		Changes
 *  1.0   	2006-12-08  ---     Version 1.0 release.
 *
 */
// @@OSGART_LICENSE_HEADER_BEGIN@@
// @@OSGART_LICENSE_HEADER_END@@

#ifndef OSGART_MARKER
#define OSGART_MARKER 1


// General
#include <string>

// STL headers
#include <vector>

// local headers
#include "osgART/Export"
#include "osgART/Field"

// OSG headers
#include <osg/Matrix>
#include <osg/Vec3>
#include <osg/Referenced>
#include <osg/ImageStream>


namespace osgART {

	/**
	* \class Marker
	* \brief A base class from which specific types of markers are derived.
	*/
	class OSGART_EXPORT Marker : public osg::Referenced, public FieldContainer<Marker>
	{
	public:
	
        virtual bool isSameKindAs(const osg::Object* obj) const {
            return dynamic_cast<const Marker*>(obj) != 0L;
        }
        virtual const char* className() const { return "Marker"; }

		enum MarkerType 
		{
			ART_UNKOWN = 0,	//<! unknown marker type
			ART_SINGLE,		//<! a single marker
			ART_MULTI,		//<! a multimarker
			ART_NFT,		//<! a natural feature
			ART_BAZAR
		};
		
		/** 
		* \brief default constructor.
		*
		*/
		Marker();

		/**
		* Return the type of the Marker. 
		* \return type of marker
		*/
		virtual MarkerType getType() const = 0;
		
		/**
		* Determine if the marker is visible.
		* Return the validity of the marker, mainly valid with no occlusion,
		* no loss of tracking, in the FOV of the camera, correct recognition, etc.
		* \return the validity of the marker (true if valid).
		*/
		virtual bool isValid() const;

		/**
		* Obtain the transformation of the marker.
		* Return return a 4x4 transformation of the marker (european order).
		* \return a 4x4 matrix
		*/
		const osg::Matrix& getTransform() const;


		/**
		 * Set smoothing factor for rotations.
		 * \param r 		 
		 */
		void setRotationalSmoothing(float r);
		
		/** Get smooting factor for rotations.
		 * \return smoothing factor
		 */		 
		float getRotationalSmoothing() const;
		 			 	
		/**
		 * Set smoothing factor for translations.
		 * \param t 		 
		 */	
		void setTranslationalSmoothing(float t);
		
		/** Get smooting factor for translation.
		 * \return smoothing factor
		 */		 
		float getTranslationalSmoothing() const;

		/**
		* \brief set name of the marker
		* \param name identifier name for the marker
		*/
		void setName(const std::string& name);
		
		/** 
		* \brief retrieve name of the marker
		* \return marker name 
		*/
		const std::string& getName() const;

		/**
		* \brief set the respective marker active 
		* \param active set to TRUE if the marker should be tracked
		*/
		virtual void setActive(bool active) = 0;	

		/**
		* \brief retrieve activity status from the marker
		* \return TRUE if the marker is active
		*/
		bool isActive() const;
		
		struct Callback : public osg::Referenced
		{
            /** do customized update code.*/
            virtual void operator ()(Marker* m) = 0;	
		};
				
		
		void copyData(const Marker& marker);
		
		void setFilterCallback(Callback* callback);
		
		Callback* getFilterCallback();
	
	protected: 
	
	
		/**
		* \brief destructor.
		*/
		virtual ~Marker(); 
		
	protected:
	
		osg::ref_ptr<Callback> m_updatecallback;
		
		osg::ref_ptr<Callback> m_filtercallback;
	
		friend class MarkerContainer;
		
	
		/**
		 * Internal update of matrix
		 */
		void updateTransform(const osg::Matrix& transform);
		
		
		bool m_valid;		
		bool m_active;
		
		osg::Matrix m_transform;
		
		std::string m_name;
				

		/**
		* Filtering transformation matrices
		*/
		bool							m_doTransFiltering;


		/**
		* old transformation averaging
		*/
		osg::Vec3 m_storedPosition;
		osg::Quat m_storedRotation;

		float m_positionSmoothFactor;
		float m_rotationSmoothFactor;
				
		bool m_seen;
		
	};
	
	class MarkerContainerCallback;
	
	class OSGART_EXPORT MarkerContainer : public Marker 
	{
	public:
	
		MarkerContainer(Marker* marker);
		
		/**
		* \brief set the respective marker active 
		* \param active set to TRUE if the marker should be tracked
		*/
		virtual void setActive(bool active);	
		
		virtual bool isValid() const;
		
		virtual MarkerType getType() const;
		
	protected:	
	
		friend class MarkerContainerCallback;
	
		osg::ref_ptr<Marker> m_marker;

	
	};

};

#endif
