/*
 *	osgART/VideoLoadModel
 *	osgART: AR ToolKit for OpenSceneGraph
 *
 *	Copyright (c) 2005-2007 ARToolworks, Inc. All rights reserved.
 *	
 *	Rev		Date		Who		Changes
 *  1.0   	2006-12-08  ---     Version 1.0 release.
 *
 */
// @@OSGART_LICENSE_HEADER_BEGIN@@
// @@OSGART_LICENSE_HEADER_END@@

#ifndef OSGART_VIDEOLOADMODEL
#define OSGART_VIDEOLOADMODEL 1

// graphics include
#include <osg/Node>
#include <osg/Group>
#include <osg/MatrixTransform>
#include <osg/Geometry>
#include <osg/Projection>


// local include
#include "osgART/Export"
#include "osgART/GenericVideoObject"
#include "osgART/GenericVideo"

namespace osgART {

	/**
	* \class VideoLoadModel.
	* download an external geometry which will be textured by a video object.
	* PRE-CONDITION: user need to be sure the correct texture coordinate
	* are present on the file.
	* REM: just work with basic texture type, not texture rectangle.
	*
	*/
	class OSGART_EXPORT VideoLoadModel : public GenericVideoObject
	{
	public:        
		/** 
		 * \brief default constructor.
		 * \param videoId the number of the video used for the background
		 * \param video_name name of the video object used to be video textured
		 */
		VideoLoadModel(int videoId,const char* video_name);
		
		
		VideoLoadModel(const GenericVideo& video);
	    
		/**
		 * \brief destructor.
		 */
		virtual ~VideoLoadModel();

		/**
		 * Initialize
		 */    
		virtual void init();
	
	
		/**
		\brief crop the video input to a sub area
		\param x starting x position (in pixels)
		\param y starting y position (in pixels)
		\param width width of subimage (in pixels)
		\param height height of subimage (in pixels)
		\param crop do the crop (if false former stuff will be ignored)
		*/
		virtual void cropVideo(int x, int y, int width, int height,bool crop = true) {
			m_isCroop=crop;m_cropX=x;m_cropY=y;m_cropWidth=width;m_cropHeight=height; 
		};
		
		/**
		\brief activate the chroma key color
		*/
		inline virtual void setMatte(bool _matte) {m_isMatte=_matte;};
		
		/** 
		\brief return if using the chroma key color
		*/
		inline virtual bool getMatte() const {
			return m_isMatte;
		}
		
		/**
		\brief use a file for video matting
		*/
		inline virtual void setMatteVideo(int videoId) {
			m_videoMatteId=videoId;
		};
		
		inline virtual int getMatteVideo() const {
			return m_videoMatteId;
		}
		
				
		/**
		\brief use a file for video matting
		*/
		inline virtual void setMatteColor(osg::Vec3f color) {m_matteColor=color;};
				
		/**
		\brief activate the chroma key color
		*/
		inline virtual void setChroma(bool _chroma) {m_isChroma=_chroma;};
				
		/**
		\brief setup the chroma key color
		*/
		inline virtual void setChromaColor(osg::Vec3f color) {m_chromaColor=color;};
		
	protected:
		
		osg::Node* buildVideoModel();
		osg::Node* buildGeometry();
		
	private:
	
		int m_videoMatteId;
		
		osg::Vec3f  m_matteColor;
		osg::Vec3f  m_chromaColor;
		
		int m_cropX;
		int m_cropY;
		int m_cropWidth;
		int m_cropHeight;
		
		bool m_isCroop;
		bool m_isMatte;
		bool m_isChroma;
		
		osg::Group*	m_root;
		
		osg::MatrixTransform*	m_ModelMatrix;
		//osg::Geometry*			m_geometry;
		osg::Node*			m_geometry;
		osg::Geode*				m_backGeode;
		
		float m_width;
		float m_height;
		
		std::string m_modelName;
		
	};
};
#endif

