/*
 *	osgART/GenericVideo
 *	osgART: AR ToolKit for OpenSceneGraph
 *
 *	Copyright (c) 2005-2007 ARToolworks, Inc. All rights reserved.
 *	
 *	Rev		Date		Who		Changes
 *  1.0   	2006-12-08  ---     Version 1.0 release.
 *
 */
// @@OSGART_LICENSE_HEADER_BEGIN@@
// @@OSGART_LICENSE_HEADER_END@@

#ifndef OSGART_GENERICVIDEO
#define OSGART_GENERICVIDEO 1

// OSG include
#include <osg/ref_ptr>
#include <osg/Image>
#include <osg/ImageStream>
#include <osg/Object>

// Local include
#include "osgART/Export"
#include "osgART/VideoImageStream"
#include "osgART/VideoConfig"
#include "osgART/Field"

// OpenThreads
#include <OpenThreads/ScopedLock>
#include <OpenThreads/Mutex>

namespace osgART {
	/**
	 * GenericVideo encapsulates different capturing devices and sources. 
	 * 
	 */	
	class OSGART_EXPORT GenericVideo : public VideoImageStream, 
		public FieldContainer<GenericVideo>
	{
	public:
	
		/** 
		 * Default constructor. Initializes also the FieldContainer 
		 * explicitly.
		 */
		GenericVideo();
	    
		/** 
		 * Copy constructor. Needed for cloning in OSG
		 */
		GenericVideo(const GenericVideo& container,
			const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	    
		/** 
		 * \brief assignemnt operator.
		 *
		 */
		GenericVideo& operator = (const GenericVideo &);
	
        virtual osg::Object* cloneType() const 
        { 
			return new GenericVideo(); 
		}
        
        virtual osg::Object* clone(const osg::CopyOp& copyop) const 
        { 
			return new GenericVideo(*this,copyop); 
		}
			
        virtual bool isSameKindAs(const osg::Object* obj) const 
        {
			return dynamic_cast<const GenericVideo*>(obj) != 0; 
		}
        
        virtual const char* libraryName() const 
        {
			return "osgART"; 
		}
        
        virtual const char* className() const 
        {
			return "GenericVideo";
		}	
	
		/**
		* \brief x size of the GenericVideo.
		* @return the width of the GenericVideo stream.
		*/
		int getWidth() const;

		/**
		* \brief y size of the GenericVideo.
		* @return the height of the GenericVideo stream.
		*/
		int getHeight() const;

			
		/**
		* \brief get GenericVideo id.
		* @return a GenericVideo identifier.
		*/
		virtual int getID() const;
		
		
		/** 
		 * Get the mutex for a video object to lock against read/write operations
		 * \return reference to the internal mutex
		 */
		inline OpenThreads::Mutex& getMutex() 
		{
			return m_mutex;		
		}
		
		/**
		 * Access a field by its name. You need to cast
		 * the field into its respective type in order
		 * to access it.
		 * \param name Name of the field
		 * \return pointer to the field (0L if not found)
		 */
		Field* get(const std::string& name);
		
		
		/**
		 * Get the video configuration struct
		 * \return struct VideoConfiguration
		 */
		virtual VideoConfiguration* getVideoConfiguration();
		
		
		/**
		 * Set internal flipping. 
		 * \param horizontal switch on and off horizontal flipping
		 * \param vertical switch on and off vertical flipping
		 */
		void setFlip(bool horizontal, bool vertical);
		
		/**
		 * Needed for plugin loaded objects which are used in other
		 * languages which don't support dynamic casting (e.g. Python)
		 * \param instance instance to be casted to a tracker
		 * \return 0 if can't cast otherwise correctly typed instance
		 */
		static GenericVideo* cast(osg::Referenced* instance);

		
	   
	protected:
	
		bool m_vertical_flip;
		bool m_horizontal_flip;
		
		/** 
		 * \brief destructor.
		 *
		 */
		virtual ~GenericVideo();   
				
		int m_video_id;
			
		static int videoNum;
		
		// used for locking
		OpenThreads::Mutex m_mutex;
		
	}; // class GenericVideo

	/**
     * The VideoContainer encapsulates a video object.
	 * Its single purpose of existance is to get arround restrictions
	 * within osgIntrospection and RTTI accross DLL boundaries.
	 */
	class OSGART_EXPORT VideoContainer : public GenericVideo {
	public:
	
		META_Object(osgART, VideoContainer)	
		
		VideoContainer(GenericVideo* video = 0L);
		
		VideoContainer(const VideoContainer& container,
			const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);


		VideoConfiguration* getVideoConfiguration();

	    
		/**
		* \brief open the internal video stream.
		* Access the GenericVideo stream (hardware or file) and get an handle on it.
		*/
		virtual void open();
		
		/**
		* \brief close the video stream.
		* Terminate the connection with the video stream and clean handle.
		*/
		virtual void close();
		
		/**
		* \brief start the  video stream grabbing.
		* Start to get image from the  video stream. In function of the implementation on different
		* platform, this function can run a thread, signal or real-time function. 
		*/
		virtual void start();
		
		/**
		* \brief stop the  video stream grabbing.
		* Stop to get image from the  video stream. In function of the implementation on different
		* platform, this function can stop a thread, signal or real-time function. 
		*/
		virtual void stop();
		
		/**
		* \brief update the  video stream grabbing.
		* Try to get an image of the  video instance, usable by your application.
		*/
		virtual void update();		
		
		virtual void releaseImage();
		
		/**
		 * Load a plugin in the video container.
		 * \param plugin name of the plugin (excluding the extension)
		 */
		void load(const std::string& plugin);
		
	protected:

		virtual ~VideoContainer();

		osg::ref_ptr<GenericVideo> m_encapsulated;

	}; // class VideoContainer
	
}; // namespace osgART

#endif
