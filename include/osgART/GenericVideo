/*
 *	osgART/GenericVideo
 *	osgART: AR ToolKit for OpenSceneGraph
 *
 *	Copyright (c) 2005-2007 ARToolworks, Inc. All rights reserved.
 *	
 *	Rev		Date		Who		Changes
 *  1.0   	2006-12-08  ---     Version 1.0 release.
 *
 */
// @@OSGART_LICENSE_HEADER_BEGIN@@
// @@OSGART_LICENSE_HEADER_END@@

#ifndef OSGART_GENERICVIDEO
#define OSGART_GENERICVIDEO 1

// OSG include
#include <osg/ref_ptr>
#include <osg/Image>
#include <osg/ImageStream>
#include <osg/Object>

// Local include
#include "osgART/Export"
#include "osgART/VideoImageStream"
#include "osgART/VideoConfig"
#include "osgART/Field"



#include <OpenThreads/ScopedLock>
#include <OpenThreads/Mutex>

namespace osgART {
	/**
	 * GenericVideo encapsulates different capturing devices and sources. 
	 * 
	 */	
	class OSGART_EXPORT GenericVideo : public VideoImageStream, 
		public FieldContainer<GenericVideo>
	{
	public:
	
		
		/** 
		 * Default constructor. Initializes also the FieldContainer 
		 * explicitly.
		 */
		GenericVideo();
	    
		/** 
		 * Copy constructor. Needed for cloning in OSG
		 */
		GenericVideo(const GenericVideo& container,
			const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);
	    
		/** 
		* \brief affectation operator.
		*
		*/
		GenericVideo& operator = (const GenericVideo &);
	   
		/**
		* \brief x size of the GenericVideo.
		* @return the width of the GenericVideo stream.
		*/
		int getWidth() const;

		/**
		* \brief y size of the GenericVideo.
		* @return the height of the GenericVideo stream.
		*/
		int getHeight() const;

		/**
		* \brief pixel size of the GenericVideo.
		* @return the pixel size of the GenericVideo stream in number of components.
		*/
		inline int pixelSize() const {
			return pixelsize;
		}

		/**
		* \brief return the type of the pixel format
		* @return pixel format of the video image returned: from RGB to YUV format. 
		*/
		inline PixelFormatType pixelFormat() const {
			return pixelformat;
		}
		
		/**
		 * \brief return the type of the pixel format in OpenGL terms.
		 * @return An integer value less than 0 if an error occured. 
		 */
		void getGLPixelFormat(GLenum *internalformat_GL, GLenum *format_GL, GLenum *type_GL);
		
		/**
		* \brief return the frame rate
		* @return actual frame rate used by the camera
		*/
		inline FrameRateType frameRate() const {
			return framerate;
		}
		
		/**
		* \brief get GenericVideo id.
		* @return a GenericVideo identifier.
		*/
		virtual int getID() const;
		
		/**
		 * \brief get an image.
		 * Get the last image retrieved since call of update.
		 */
		unsigned char* getImageRaw();

		inline OpenThreads::Mutex& getMutex() {
			return m_mutex;		
		}
		
		/**
		 * Access a field by its name. You need to cast
		 * the field into its respective type in order
		 * to access it.
		 * \param name Name of the field
		 * \return pointer to the field (0L if not found)
		 */
		Field* get(const std::string& name);
		
		
		/**
		 * Get the video configuration struct
		 * \return struct VideoConfiguration
		 */
		virtual VideoConfiguration* getVideoConfiguration();
		
		
		/**
		 * Set internal flipping. 
		 * \param horizontal switch on and off horizontal flipping
		 * \param vertical switch on and off vertical flipping
		 */
		void setFlip(bool horizontal, bool vertical);
		
		
		/**
		 * For on demand update. It will try to call update and 
		 * return true if this is a new frame.
		 * \return true if a new frame has been captured
		 */
		bool getFrame();
		
	   
	protected:
	
		bool m_vertical_flip;
		bool m_horizontal_flip;
		
		bool m_isupdated;
	
		/** 
		 * \brief destructor.
		 *
		 */
		virtual ~GenericVideo();   
		int pixelsize;
		
		PixelFormatType pixelformat;
		FrameRateType framerate;
		
		GLenum m_internalformat_GL;
		GLenum m_format_GL;
		GLenum m_type_GL;
		
		int m_video_id;
			
		static int videoNum;
		
		// used for locking
		OpenThreads::Mutex m_mutex;
		
	}; // class GenericVideo

	/**
     * The VideoContainer encapsulates a video object.
	 * Its single purpose of existance is to get arround restrictions
	 * within osgIntrospection and RTTI accross DLL boundaries.
	 */
	class OSGART_EXPORT VideoContainer : public GenericVideo {
	public:
	
		META_Object(osgART, VideoContainer)	
		
		VideoContainer(GenericVideo* video = 0L);
		
		VideoContainer(const VideoContainer& container,
			const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY);


		VideoConfiguration* getVideoConfiguration();

	    
		/**
		* \brief open the internal video stream.
		* Access the GenericVideo stream (hardware or file) and get an handle on it.
		*/
		virtual void open();
		
		/**
		* \brief close the video stream.
		* Terminate the connection with the video stream and clean handle.
		*/
		virtual void close();
		
		/**
		* \brief start the  video stream grabbing.
		* Start to get image from the  video stream. In function of the implementation on different
		* platform, this function can run a thread, signal or real-time function. 
		*/
		virtual void start();
		
		/**
		* \brief stop the  video stream grabbing.
		* Stop to get image from the  video stream. In function of the implementation on different
		* platform, this function can stop a thread, signal or real-time function. 
		*/
		virtual void stop();
		
		/**
		* \brief update the  video stream grabbing.
		* Try to get an image of the  video instance, usable by your application.
		*/
		virtual void update();		
		
		virtual void releaseImage();
		
		/**
		 * Load a plugin in the video container.
		 * \param plugin name of the plugin (excluding the extension)
		 */
		void load(const std::string& plugin);
		
	protected:

		virtual ~VideoContainer();

		osg::ref_ptr<GenericVideo> m_encapsulated;

	}; // class VideoContainer
	
}; // namespace osgART

#endif
